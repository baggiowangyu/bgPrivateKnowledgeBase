# 第二部分：容器

## 介绍

是时候开始以Docker的方式构建应用程序了。我们从这类应用程序的层次结构的底部开始，容器，本页面将介绍它。
在此级别之上是一个服务，它定义容器在生产环境中的行为方式，在第3部分中介绍。
最后，在顶层是堆栈，定义了第5部分中介绍的所有服务的交互。

- Stack
- Services
- **Container**(我们在这)

## 您的新开发环境

在过去，如果要开始编写Python应用程序，首先要做的是在机器上安装Python运行时。但是这引发了一个新问题：不仅我们自己的开发环境需要完美的运行我的app，而且我们的生产环境也需要。

使用Docker，您只需获取一个可移植的Python运行时作为映像，无需安装。然后，您的构建可以在应用程序代码旁边包含基本Python映像，从而确保应用程序及其依赖项和运行时一起运行。

这种可移植的映像由一种称为 **Dockerfile** 的东西定义。

## 使用Dockerfile定义一个容器

**Dockerfile** 定义容器内的环境中发生的事情。对网络接口和磁盘驱动器等资源的访问是在此环境中虚拟化的，该环境与系统的其他部分是隔离的，因此您需要将端口映射到外部世界，并指定要“复制”到该环境中的文件。然而，这样做之后，您可以期望在这个Dockerfile中定义的应用程序构建在运行时的行为完全相同。

### Dockerfile

创建一个空目录。将目录(cd)更改为新目录，创建一个名为Dockerfile的文件，复制并粘贴以下内容到该文件中，然后保存它。注意解释新Dockerfile中每个语句的注释。

```
# Use an official Python runtime as a parent image
FROM python:2.7-slim

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]
```

这个Dockerfile引用了两个我们还没有创建的文件，即app.py和requirements.txt。接下来让我们创建它们。

## 应用程序本身(The app itself)

再创建两个文件，**requirements.txt** 和 **app.py** 。将它们与Dockerfile放在同一个文件夹中。这就完成了我们的应用程序，正如您所看到的，它非常简单。当上面的Dockerfile被构建到一个映像....

### requirements.txt

```
Flask
Redis
```

### app.py

```
from flask import Flask
from redis import Redis, RedisError
import os
import socket

# Connect to Redis
redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)

app = Flask(__name__)

@app.route("/")
def hello():
    try:
        visits = redis.incr("counter")
    except RedisError:
        visits = "<i>cannot connect to Redis, counter disabled</i>"

    html = "<h3>Hello {name}!</h3>" \
           "<b>Hostname:</b> {hostname}<br/>" \
           "<b>Visits:</b> {visits}"
    return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
```

现在我们看到 **```pip install -r requirements.txt```** 安装了Flask和Redis的Python库，并且app打印了环境变量 **```NAME```** ，并且输出了 **```socket.gethostname()```** 的调用结果。最后，因为Redis没有运行(因为我们只安装了Python库，而没有安装Redis本身)，所以我们应该期望在这里使用它的尝试失败并产生错误消息。

```
注意：在容器中访问主机名时检索容器ID，容器ID类似于正在运行的可执行文件的进程ID
```

就是这样！我们不用在自己的系统中安装python，或 **requirements.txt** 中的任何东西，也不用在自己的系统上安装镜像进行构建和运行。看起来您并没有真正使用Python和Flask设置一个环境，但是您已经设置了。

## 构建应用程序(Build the app)

我们已经准备好构建这个应用程序。确保您仍然位于新目录的顶层。下面是 **ls** 应该展示的:

```
$ ls
Dockerfile		app.py			requirements.txt
```
