// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tunnel_protocol.proto

package tunnel_protocol

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MainType int32

const (
	MainType_MainType_None MainType = 0
	MainType_Business      MainType = 1
	MainType_Exception     MainType = 2
)

var MainType_name = map[int32]string{
	0: "MainType_None",
	1: "Business",
	2: "Exception",
}

var MainType_value = map[string]int32{
	"MainType_None": 0,
	"Business":      1,
	"Exception":     2,
}

func (x MainType) String() string {
	return proto.EnumName(MainType_name, int32(x))
}

func (MainType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054270405906c1d1, []int{0}
}

type SubType int32

const (
	SubType_SubType_None SubType = 0
	SubType_Request      SubType = 1
	SubType_Response     SubType = 2
)

var SubType_name = map[int32]string{
	0: "SubType_None",
	1: "Request",
	2: "Response",
}

var SubType_value = map[string]int32{
	"SubType_None": 0,
	"Request":      1,
	"Response":     2,
}

func (x SubType) String() string {
	return proto.EnumName(SubType_name, int32(x))
}

func (SubType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054270405906c1d1, []int{1}
}

type NetType int32

const (
	NetType_None NetType = 0
	NetType_TCP  NetType = 1
	NetType_UDP  NetType = 2
)

var NetType_name = map[int32]string{
	0: "None",
	1: "TCP",
	2: "UDP",
}

var NetType_value = map[string]int32{
	"None": 0,
	"TCP":  1,
	"UDP":  2,
}

func (x NetType) String() string {
	return proto.EnumName(NetType_name, int32(x))
}

func (NetType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_054270405906c1d1, []int{2}
}

type TunnelProtocol struct {
	// MappingId,
	MappingID            int32    `protobuf:"varint,1,opt,name=MappingID,proto3" json:"MappingID,omitempty"`
	SrcCliAddr           string   `protobuf:"bytes,2,opt,name=SrcCliAddr,proto3" json:"SrcCliAddr,omitempty"`
	DstSrvAddr           string   `protobuf:"bytes,3,opt,name=DstSrvAddr,proto3" json:"DstSrvAddr,omitempty"`
	Net                  NetType  `protobuf:"varint,4,opt,name=Net,proto3,enum=tunnel_protocol.NetType" json:"Net,omitempty"`
	Data                 []byte   `protobuf:"bytes,5,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelProtocol) Reset()         { *m = TunnelProtocol{} }
func (m *TunnelProtocol) String() string { return proto.CompactTextString(m) }
func (*TunnelProtocol) ProtoMessage()    {}
func (*TunnelProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_054270405906c1d1, []int{0}
}

func (m *TunnelProtocol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TunnelProtocol.Unmarshal(m, b)
}
func (m *TunnelProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TunnelProtocol.Marshal(b, m, deterministic)
}
func (m *TunnelProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelProtocol.Merge(m, src)
}
func (m *TunnelProtocol) XXX_Size() int {
	return xxx_messageInfo_TunnelProtocol.Size(m)
}
func (m *TunnelProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelProtocol proto.InternalMessageInfo

func (m *TunnelProtocol) GetMappingID() int32 {
	if m != nil {
		return m.MappingID
	}
	return 0
}

func (m *TunnelProtocol) GetSrcCliAddr() string {
	if m != nil {
		return m.SrcCliAddr
	}
	return ""
}

func (m *TunnelProtocol) GetDstSrvAddr() string {
	if m != nil {
		return m.DstSrvAddr
	}
	return ""
}

func (m *TunnelProtocol) GetNet() NetType {
	if m != nil {
		return m.Net
	}
	return NetType_None
}

func (m *TunnelProtocol) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type TunnelSecProtocol struct {
	Magic                string          `protobuf:"bytes,1,opt,name=Magic,proto3" json:"Magic,omitempty"`
	Version              string          `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	Main                 MainType        `protobuf:"varint,3,opt,name=Main,proto3,enum=tunnel_protocol.MainType" json:"Main,omitempty"`
	Sub                  SubType         `protobuf:"varint,4,opt,name=Sub,proto3,enum=tunnel_protocol.SubType" json:"Sub,omitempty"`
	IsSec                bool            `protobuf:"varint,5,opt,name=IsSec,proto3" json:"IsSec,omitempty"`
	SecData              []byte          `protobuf:"bytes,6,opt,name=SecData,proto3" json:"SecData,omitempty"`
	Data                 *TunnelProtocol `protobuf:"bytes,7,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *TunnelSecProtocol) Reset()         { *m = TunnelSecProtocol{} }
func (m *TunnelSecProtocol) String() string { return proto.CompactTextString(m) }
func (*TunnelSecProtocol) ProtoMessage()    {}
func (*TunnelSecProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_054270405906c1d1, []int{1}
}

func (m *TunnelSecProtocol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TunnelSecProtocol.Unmarshal(m, b)
}
func (m *TunnelSecProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TunnelSecProtocol.Marshal(b, m, deterministic)
}
func (m *TunnelSecProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelSecProtocol.Merge(m, src)
}
func (m *TunnelSecProtocol) XXX_Size() int {
	return xxx_messageInfo_TunnelSecProtocol.Size(m)
}
func (m *TunnelSecProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelSecProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelSecProtocol proto.InternalMessageInfo

func (m *TunnelSecProtocol) GetMagic() string {
	if m != nil {
		return m.Magic
	}
	return ""
}

func (m *TunnelSecProtocol) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *TunnelSecProtocol) GetMain() MainType {
	if m != nil {
		return m.Main
	}
	return MainType_MainType_None
}

func (m *TunnelSecProtocol) GetSub() SubType {
	if m != nil {
		return m.Sub
	}
	return SubType_SubType_None
}

func (m *TunnelSecProtocol) GetIsSec() bool {
	if m != nil {
		return m.IsSec
	}
	return false
}

func (m *TunnelSecProtocol) GetSecData() []byte {
	if m != nil {
		return m.SecData
	}
	return nil
}

func (m *TunnelSecProtocol) GetData() *TunnelProtocol {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("tunnel_protocol.MainType", MainType_name, MainType_value)
	proto.RegisterEnum("tunnel_protocol.SubType", SubType_name, SubType_value)
	proto.RegisterEnum("tunnel_protocol.NetType", NetType_name, NetType_value)
	proto.RegisterType((*TunnelProtocol)(nil), "tunnel_protocol.TunnelProtocol")
	proto.RegisterType((*TunnelSecProtocol)(nil), "tunnel_protocol.TunnelSecProtocol")
}

func init() { proto.RegisterFile("tunnel_protocol.proto", fileDescriptor_054270405906c1d1) }

var fileDescriptor_054270405906c1d1 = []byte{
	// 378 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xcf, 0x8b, 0x9b, 0x40,
	0x14, 0xc7, 0x3b, 0xc6, 0x44, 0x7d, 0xf9, 0xd1, 0xc9, 0xd0, 0x82, 0x85, 0xd2, 0x4a, 0xa0, 0x20,
	0x42, 0x73, 0x48, 0xa0, 0x87, 0xde, 0xda, 0xd8, 0x43, 0x0e, 0x09, 0x61, 0x26, 0xed, 0x35, 0xa8,
	0x19, 0x82, 0x10, 0x46, 0xeb, 0x8c, 0xa5, 0x7b, 0xde, 0xff, 0x67, 0xff, 0xc6, 0x65, 0x46, 0xdd,
	0xec, 0x26, 0xec, 0xed, 0xfb, 0xe3, 0x39, 0x7c, 0x9e, 0x0f, 0xde, 0xab, 0x5a, 0x08, 0x7e, 0x3e,
	0x94, 0x55, 0xa1, 0x8a, 0xac, 0x38, 0xcf, 0x8d, 0x20, 0x6f, 0xaf, 0xe2, 0xd9, 0x03, 0x82, 0xc9,
	0xde, 0x64, 0xbb, 0x36, 0x22, 0x1f, 0xc1, 0xdb, 0x24, 0x65, 0x99, 0x8b, 0xd3, 0x3a, 0xf6, 0x51,
	0x80, 0xc2, 0x3e, 0xbd, 0x04, 0xe4, 0x13, 0x00, 0xab, 0xb2, 0xd5, 0x39, 0xff, 0x71, 0x3c, 0x56,
	0xbe, 0x15, 0xa0, 0xd0, 0xa3, 0xcf, 0x12, 0xdd, 0xc7, 0x52, 0xb1, 0xea, 0x9f, 0xe9, 0x7b, 0x4d,
	0x7f, 0x49, 0x48, 0x04, 0xbd, 0x2d, 0x57, 0xbe, 0x1d, 0xa0, 0x70, 0xb2, 0xf0, 0xe7, 0xd7, 0x98,
	0x5b, 0xae, 0xf6, 0x77, 0x25, 0xa7, 0x7a, 0x88, 0x10, 0xb0, 0xe3, 0x44, 0x25, 0x7e, 0x3f, 0x40,
	0xe1, 0x88, 0x1a, 0x3d, 0xbb, 0xb7, 0x60, 0xda, 0x00, 0x33, 0x9e, 0x3d, 0x31, 0xbf, 0x83, 0xfe,
	0x26, 0x39, 0xe5, 0x99, 0xe1, 0xf5, 0x68, 0x63, 0x88, 0x0f, 0xce, 0x1f, 0x5e, 0xc9, 0xbc, 0x10,
	0x2d, 0x68, 0x67, 0xc9, 0x57, 0xb0, 0x37, 0x49, 0x2e, 0x0c, 0xdf, 0x64, 0xf1, 0xe1, 0x06, 0x43,
	0x97, 0x86, 0xc3, 0x8c, 0x69, 0x68, 0x56, 0xa7, 0xaf, 0x42, 0xb3, 0x3a, 0x6d, 0xa0, 0x59, 0x9d,
	0x6a, 0x94, 0xb5, 0x64, 0x3c, 0x33, 0xd4, 0x2e, 0x6d, 0x8c, 0x46, 0x61, 0x3c, 0x33, 0xdb, 0x0c,
	0xcc, 0x36, 0x9d, 0x25, 0xcb, 0x76, 0x49, 0x27, 0x40, 0xe1, 0x70, 0xf1, 0xf9, 0xe6, 0xf1, 0x97,
	0xd7, 0x69, 0xfe, 0x42, 0xf4, 0x1d, 0xdc, 0x0e, 0x91, 0x4c, 0x61, 0xdc, 0xe9, 0xc3, 0xb6, 0x10,
	0x1c, 0xbf, 0x21, 0x23, 0x70, 0x7f, 0xd6, 0x32, 0x17, 0x5c, 0x4a, 0x8c, 0xc8, 0x18, 0xbc, 0x5f,
	0xff, 0x33, 0x5e, 0xaa, 0xbc, 0x10, 0xd8, 0x8a, 0xbe, 0x81, 0xd3, 0x02, 0x13, 0x0c, 0xa3, 0x56,
	0x76, 0x5f, 0x0e, 0xc1, 0xa1, 0xfc, 0x6f, 0xcd, 0xa5, 0xc2, 0x48, 0x3f, 0x43, 0xb9, 0x2c, 0x0b,
	0x21, 0x39, 0xb6, 0xa2, 0x2f, 0xe0, 0xb4, 0xd7, 0x21, 0x2e, 0xd8, 0xed, 0xbc, 0x03, 0xbd, 0xfd,
	0x6a, 0x87, 0x91, 0x16, 0xbf, 0xe3, 0x1d, 0xb6, 0xd2, 0x81, 0x21, 0x5f, 0x3e, 0x06, 0x00, 0x00,
	0xff, 0xff, 0x23, 0x19, 0x4d, 0x39, 0x82, 0x02, 0x00, 0x00,
}
